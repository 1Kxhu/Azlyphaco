<!DOCTYPE html><!-- By Microsoft and EthanMcBloxxer under the MIT License (see the end of this document) -->
<html lang="en" style="width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;">

<head><meta charset="utf-8" /><title></title></head>

<body style="width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;">
	<div id="container" style="width:100%; height:100%;"></div>
	<script type="text/javascript">/* FileSaver.js //purl.eligrey.com/github/FileSaver.js (MIT License) */ var saveAs=saveAs ||(typeof navigator!=="undefined"&&navigator.msSaveOrOpenBlob&&navigator.msSaveOrOpenBlob.bind(navigator))||(function(view){"use strict";if(typeof navigator!=="undefined"&&/MSIE [1-9]\./.test(navigator.userAgent)){return}var doc=view.document,get_URL=function(){return view.URL||view.webkitURL||view},save_link=doc.createElementNS("http://www.w3.org/1999/xhtml","a"),can_use_save_link=!view.externalHost&&"download"in save_link,click=function(node){var event=doc.createEvent("MouseEvents");event.initMouseEvent("click",true,false,view,0,0,0,0,0,false,false,false,false,0,null);node.dispatchEvent(event)},webkit_req_fs=view.webkitRequestFileSystem,req_fs=view.requestFileSystem||webkit_req_fs||view.mozRequestFileSystem,throw_outside=function(ex){(view.setImmediate||view.setTimeout)(function(){throw ex},0)},force_saveable_type="application/octet-stream",fs_min_size=0,deletion_queue=[],process_deletion_queue=function(){var i=deletion_queue.length;while(i--){var file=deletion_queue[i];if(typeof file==="string"){get_URL().revokeObjectURL(file)}else{file.remove()}}deletion_queue.length=0;},dispatch=function(filesaver,event_types,event){event_types=[].concat(event_types);var i=event_types.length;while(i--){var listener=filesaver["on"+event_types[i]];if(typeof listener==="function"){try{listener.call(filesaver,event||filesaver)}catch(ex){throw_outside(ex)}}}},FileSaver=function(blob,name){var filesaver=this,type=blob.type,blob_changed=false,object_url,target_view,get_object_url=function(){var object_url=get_URL().createObjectURL(blob);deletion_queue.push(object_url);return object_url},dispatch_all=function(){dispatch(filesaver,"writestart progress write writeend".split(" "))},fs_error=function(){if(blob_changed||!object_url){object_url=get_object_url(blob)}if(target_view){target_view.location.href=object_url}else{window.open(object_url,"_blank")}filesaver.readyState=filesaver.DONE;dispatch_all()},abortable=function(func){return function(){if(filesaver.readyState!==filesaver.DONE){return func.apply(this,arguments)}}},create_if_not_found={create:true,exclusive:false},slice;filesaver.readyState=filesaver.INIT;if(!name){name="download"}if(can_use_save_link){object_url=get_object_url(blob);save_link.href=object_url;save_link.download=name;click(save_link);filesaver.readyState=filesaver.DONE;dispatch_all();return}if(view.chrome&&type&&type!==force_saveable_type){slice=blob.slice||blob.webkitSlice;blob=slice.call(blob,0,blob.size,force_saveable_type);blob_changed=true}if(webkit_req_fs&&name!=="download"){name+=".download"}if(type===force_saveable_type||webkit_req_fs){target_view=view}if(!req_fs){fs_error();return}fs_min_size+=blob.size;req_fs(view.TEMPORARY,fs_min_size,abortable(function(fs){fs.root.getDirectory("saved",create_if_not_found,abortable(function(dir){var save=function(){dir.getFile(name,create_if_not_found,abortable(function(file){file.createWriter(abortable(function(writer){writer.onwriteend=function(event){target_view.location.href=file.toURL();deletion_queue.push(file);filesaver.readyState=filesaver.DONE;dispatch(filesaver,"writeend",event)};writer.onerror=function(){var error=writer.error;if(error.code!==error.ABORT_ERR){fs_error()}};"writestart progress write abort".split(" ").forEach(function(event){writer["on"+event]=filesaver["on"+event]});writer.write(blob);filesaver.abort=function(){writer.abort();filesaver.readyState=filesaver.DONE};filesaver.readyState=filesaver.WRITING}),fs_error)}),fs_error)};dir.getFile(name,{create:false},abortable(function(file){file.remove();save()}),abortable(function(ex){if(ex.code===ex.NOT_FOUND_ERR){save()}else{fs_error()}}))}),fs_error)}),fs_error)},FS_proto=FileSaver.prototype,saveAs=function(blob,name){return new FileSaver(blob,name)};FS_proto.abort=function(){var filesaver=this;filesaver.readyState=filesaver.DONE;dispatch(filesaver,"abort")};FS_proto.readyState=FS_proto.INIT=0;FS_proto.WRITING=1;FS_proto.DONE=2;FS_proto.error=FS_proto.onwritestart=FS_proto.onprogress=FS_proto.onwrite=FS_proto.onabort=FS_proto.onerror=FS_proto.onwriteend=null;view.addEventListener("unload",process_deletion_queue,false);saveAs.unload=function(){process_deletion_queue();view.removeEventListener("unload",process_deletion_queue,false)};return saveAs}(typeof self!=="undefined"&&self||typeof window!=="undefined"&&window||this.content));if(typeof module!=="undefined"&&module!==null){module.exports=saveAs}else if((typeof define!=="undefined"&&define!==null)&&(define.amd!=null)){define([],function(){return saveAs})}String.prototype.endsWithAny=function(){var strArray=Array.prototype.slice.call(arguments),$this=this.toLowerCase().toString();for(var i=0;i<strArray.length;i+=1){if($this.indexOf(strArray[i],$this.length-strArray[i].length)!==-1){return true}}return false};var saveTextAs=saveTextAs||(function(textContent,fileName,charset){fileName=fileName||'download.txt';charset=charset||'utf-8';textContent=(textContent||'').replace(/\r?\n/g,"\r\n");if(saveAs&&Blob){var blob=new Blob([textContent],{type:"text/plain;charset="+charset});saveAs(blob,fileName);return true}else{var saveTxtWindow=window.frames.saveTxtWindow;if(!saveTxtWindow){saveTxtWindow=document.createElement('iframe');saveTxtWindow.id='saveTxtWindow';saveTxtWindow.style.display='none';document.body.insertBefore(saveTxtWindow,null);saveTxtWindow=window.frames.saveTxtWindow;if(!saveTxtWindow){saveTxtWindow=window.open('','_temp','width=100,height=100');if(!saveTxtWindow){window.alert('Sorry, download file could not be created.');return false}}}var doc=saveTxtWindow.document;doc.open('text/html','replace');doc.charset=charset;if(fileName.endsWithAny('.htm','.html')){doc.close();doc.body.innerHTML='\r\n'+textContent+'\r\n'}else{if(!fileName.endsWithAny('.txt')){fileName+='.txt'}doc.write(textContent);doc.close()}var retValue=doc.execCommand('SaveAs',null,fileName);saveTxtWindow.close();return retValue}});</script>
	<script src="vs/loader.js"></script>
	<script type="text/javascript">
		var editor;
		var instances = [];
		var services = [];
		var enums = [];
		var xhttp = new XMLHttpRequest();
		xhttp.onreadystatechange = function() {
			if (this.readyState == 4 && this.status == 200) {
				let json = JSON.parse(this.responseText);
				for (let index = 0; index < json["Classes"].length; index++) {
					const element = json["Classes"][index];
					if (element.Tags && element.Tags.includes("Service")) {
						services.push(element.Name);
					}
					else if (!element.Tags || !element.Tags.includes("NotCreatable")) {
						instances.push(element.Name);
						instances.sort();
					}
				}
				for (let index = 0; index < json["Enums"].length; index++) {
					enums.push(json["Enums"][index].Name);
				}
			}
			else if (this.status >= 300) {
				instances = ["Autocomplete Failed to Load", "Part"];
				services = ["Autocomplete Failed to Load", "Workspace", "Players", "Lighting", "ReplicatedStorage", "ReplicatedFirst", "StarterGui", "StarterPack", "StarterPlayer", "DataStoreService", "HttpService", "InsertService", "GroupService", "MarketplaceService", "RunService", "SoundService", "TeleportService", "TestService", "TweenService", "UserInputService"];
				enums = ["Autocomplete Failed to Load", "Font"];
			};
		};

		require(['vs/editor/editor.main'], function() {
			/* Keywords */ monaco.languages.registerCompletionItemProvider('lua', {provideCompletionItems: function () {return {suggestions: [
				{
					label: "global",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Variable",
					documentation: {value: "Declares a variable accessible throughout the entire script, but not cross-script. Prefer `local` and forward declarations / upvalues over using global variables for a 10%+ increase in performance. `global` itself is not a valid keyword. Variables can't start with a number and can't be reserved by Lua."},
					preselect: true,

					insertText: "${1:name} = ${2:datatype}",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "local",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Variable",
					documentation: {value: "Declares a scoped variable that only exists in the main executing body (with additions to descendant scope levels), or only in the block where it is declared. Omit the `local` in front of the variable to make the variable visible to all scopes. `local`s are faster than global variables by 10%+. Variables can't start with a number and can't be reserved by Lua."},
					preselect: true,

					insertText: "local ${1:name} = ${2:datatype}",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "nil",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Keyword",
					documentation: {value: "The absence of any value. `nil` itself is a representation of the fact that there is no value. You can also assign a variable to it which in turn destroys the variable. Use the Destroy() method on instances instead of assigning its parent to `nil`."},
					preselect: true,

					insertText: "nil",
				},
				{
					label: "true",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Boolean",
					documentation: {value: "Boolean type true, often used in parameters or operations. If a value isn't either `false` or `nil`, it is considered true when using conditional statements."},
					preselect: true,

					insertText: "true",
				},
				{
					label: "false",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Boolean",
					documentation: {value: "Boolean type false, often used in parameters or operations."},
					preselect: true,

					insertText: "false",
				},
				{
					label: "and",
					kind: monaco.languages.CompletionItemKind.Operator,
					detail: "Operator",
					documentation: {value: "Returns the first argument if it evaluates to `false` or `nil`, otherwise it returns the second argument."},
					preselect: true,

					insertText: "and",
				},
				{
					label: "or",
					kind: monaco.languages.CompletionItemKind.Operator,
					detail: "Operator",
					documentation: {value: "If the first argument is neither `false` nor `nil`, the first value is returned. If the first argument is `false` or `nil`, it returns the second value. Sometimes used in variable declarations as a fallback."},
					preselect: true,

					insertText: "or",
				},
				{
					label: "not",
					kind: monaco.languages.CompletionItemKind.Operator,
					detail: "Operator",
					documentation: {value: "Returns `true` if the argument is `false` or `nil`, otherwise, `false` is returned."},
					preselect: true,

					insertText: "not",
				},
				{
					label: "function",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Function",
					documentation: {value: "Functions are code that can be used multiple times throughout a script. After defining them, you can execute them through a command or trigger them with an event. You can call the function by doing `name(argument1, argument2)`. Excess arguments will be ignored, and lacking arguments will become `nil`."},
					preselect: true,

					insertText: "function ${1:name}(${2:parameters})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "function()",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Function (Anonymous)",
					documentation: {value: "A self-executing function without a name (an 'anonymous' function). Useful when you need to call a function from the result of another function or event or a connection."},
					preselect: true,

					insertText: "function(${1:parameters})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "return",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Function",
					documentation: {value: "Inside of a function, you can return data to the calling statement. Useful in arguments."},
					preselect: true,

					insertText: "return ${1:variable}",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "if",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Keyword",
					documentation: {value: "Runs the code inside of `then` and `end`, but only if the arguments you passed evaluate to true."},
					preselect: true,

					insertText: "if ${1:condition} then\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "then",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Keyword",
					documentation: {value: "Suffix for `if` and `elseif`."},

					insertText: "then\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "elseif",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Keyword",
					documentation: {value: "A combination of `if` and `else` which allows you to evaluate additional conditions in the same block."},
					preselect: true,

					insertText: "elseif ${1:condition} then\n\t$0",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "else",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Keyword",
					documentation: {value: "Provides a fallback for `if` and `elseif`, which is what to do when all of the evaluated conditions are falsy (nil, false)."},
					preselect: true,

					insertText: "else\n\t$0",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "for",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Loop",
					documentation: {value: "Run a command or group of commands (code) a set number of times. Beginning at the start value, the loop will count up by the increment variable until it reaches the end variable. The increment variable can be negative."},
					filterText: "for ",
					preselect: true,

					insertText: "for i = ${1:1}, ${2:10}, ${3:1} do\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "for ... in ?",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Loop",
					documentation: {value: "A snippet for iterator function usage with a `for` loop."},
					filterText: "for ... in ",
					preselect: true,

					insertText: "for ${1:returns} in ${2:iterator} do\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "while",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Loop",
					documentation: {value: "Runs the code inside of the loop if, when, and while the arguments evaluate to true. If the arguments evaluate to true, the loop is executed and the condition is reevaluated afterward. Includes a `wait()` to prevent the game from freezing up from overload."},
					filterText: "while ",
					preselect: true,

					insertText: "while ${1:condition} do\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "do",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Loop",
					documentation: {value: "Suffix for `for` and `while` loops. This can be used without a loop to alter the scope of variables."},

					insertText: "do\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "repeat",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Loop",
					documentation: {value: "Unlike `while`, this loop repeats until a condition is met. The code between `repeat` and `until` runs at least once since the condition is reevaluated afterward."},
					preselect: true,

					insertText: "repeat\n\t$0\nuntil ${1:condition}",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "until",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Loop",
					documentation: {value: "Suffix for `repeat`, the arguments are what is to be evaluated before executing the loop's code again."},
					preselect: true,

					insertText: "until ${1:condition}",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "break",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Loop",
					documentation: {value: "If you are running a loop that won't end normally, you can force it to break with this keyword so the script can continue running the code after the loop. Useful for infinite loops or for additional conditions."},
					preselect: true,

					insertText: "break\n",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "continue",
					kind: monaco.languages.CompletionItemKind.Keyword,
					detail: "Loop",
					documentation: {value: "Skips the current iteration of any loop. Syntactically, this is not actually a keyword."},
					preselect: true,

					insertText: "continue\n",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
			]}}});
			/* Lua Globals */ monaco.languages.registerCompletionItemProvider('lua', {provideCompletionItems: function () {return {suggestions: [
				{
					label: "assert",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Throws an error if the provided value is `false` or `nil`. If the assertion passes, it returns all values passed to it."},

					insertText: "assert(${1:value}, ${2:message})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "collectgarbage(\"count\")",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Performs a count operation on the Lua garbage collector, which returns the total Lua memory usage in kilobytes."},

					insertText: "collectgarbage(\"count\")",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "error",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Terminates the last protected function called and outputs message as an error message. If the function containing the error is not called in a protected function (pcall), then the script which called the function will terminate. The error function itself never returns and acts like a script error."},

					insertText: "error(${1:message}, ${2:level})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "getfenv",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Returns the current environment in use by the caller."},

					insertText: "getfenv($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "getmetatable",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Returns the metatable of the given table if it has one, otherwise returns nil. If it does have a metatable, and the `__metatable` metamethod is set, it returns that value instead."},

					insertText: "getmetatable($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "ipairs",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Returns three values: an iterator function, the array and the number 0. Each time the iterator function is called, it returns the next numerical index-value pair in the table. When used in a generic for-loop, the return values can be used to iterate over each numerical index in the table."},

					insertText: "ipairs($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "loadstring",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Loads Lua code from a string, and returns it as a function."},

					insertText: "loadstring($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "newproxy(true)",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Creates a blank userdata, with the option for it to have a metatable."},

					insertText: "newproxy(true)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "next",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Returns the first key/value pair in the array. If a lastKey argument was specified then returns the next element in the array based on the key that provided."},

					insertText: "next(${1:table}, ${2:lastKey})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "pairs",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Returns an iterator function, the passed table and nil, so that the construction will iterate over all key/value pairs of that table when used in a generic for-loop."},

					insertText: "pairs($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "pcall",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Calls the function with the given arguments in protected mode."},

					insertText: "local success, message = pcall($0, ${1:arguments})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "print",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Receives any number of arguments, and prints their values to the output. Uses `__tostring` instead of `tostring()`."},
					preselect: true,

					insertText: "print($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "rawequal",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Checks whether arg1 is equal to arg2, without invoking any metamethod."},

					insertText: "rawequal(${1:arg1}, ${2:arg2})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "rawget",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Gets the real value of table[index], without invoking any metamethod."},

					insertText: "rawget(${1:table}, ${2:index})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "rawset",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Sets the real value of table[index] to a given value, without invoking any metamethod."},

					insertText: "rawset(${1:table}, ${2:index}, ${3:value})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "select",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Returns all arguments after argument number index. If negative, it will return from the end of the argument list. If the first argument is '#', it returns the total number of arguments passed afterward."},

					insertText: "select(${1:index}, ${2:args})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "setfenv",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Sets the environment to be used by the given function. The first argument can be a function or a number that specifies the function at that stack level. **Do not call the function**."},

					insertText: "setfenv(${1:block}, ${2:fenv})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "setmetatable",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Sets the metatable for the given table to `metatable`. If `metatable` is nil, the metatable of t is removed. If t already has a metatable whose __metatable metamethod is set, calling this on t raises an error."},

					insertText: "setmetatable(${1:table}, ${2:metatable})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "tonumber",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Attempts to convert the arg into a number with a specified base (the optional second argument) to interpret the value in. If it cannot be converted, this function returns nil. Base is automatically 10 unless the number begins with '0x', which makes the base 16."},

					insertText: "tonumber($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "tostring",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Receives an argument of any type and converts it to a string in a reasonable format. If the metatable of the first argument has a `__tostring` metamethod, then it will be called with that as the only argument and will return the result."},

					insertText: "tostring($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "type",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Returns the type of its only argument, coded as a string."},
					tags: [monaco.languages.CompletionItemTag.Deprecated],

					insertText: "typeof($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "unpack",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "Returns the elements from the given table. By default, start is 1 and end is the length of list, as defined by the length (#) operator. `table.unpack` has the same behavior."},

					insertText: "unpack(${1:list}, ${2:start}, ${3:finish})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "xpcall",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "This function is similar to `pcall`, except that you can set a new error handler (as a function)."},

					insertText: "local success, message = xpcall($2, ${0:handler}, ${1:arguments})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "ypcall",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Lua Global",
					documentation: {value: "This function is the exact same as `pcall`, and was used to allow yielding inside of a `pcall`. That functionality is now implemented in the normal `pcall`, and as such, this function is deprecated."},
					tags: [monaco.languages.CompletionItemTag.Deprecated],

					insertText: "local success, message = pcall($0, ${1:arguments})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "_G",
					kind: monaco.languages.CompletionItemKind.Variable,
					detail: "Lua Global",
					documentation: {value: "A table that is shared between all scripts of the same context level (a table shared cross-script). This is separate from `shared`."},

					insertText: "_G.$0",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "_VERSION",
					kind: monaco.languages.CompletionItemKind.Variable,
					detail: "Lua Global",
					documentation: {value: "A global variable (not a function) that holds a string containing the current interpreter version."},

					insertText: "_VERSION",
				},
			]}}});
			/* Datatypes */ monaco.languages.registerCompletionItemProvider('lua', {provideCompletionItems: function () {return {suggestions: [

			
				// DateTime

				{
					label: "DateTime.now",
					kind: monaco.languages.CompletionItemKind.Constructor,
					detail: "Constructor",
					documentation: {value: "Creates a new DateTime representing the current moment in time."},

					insertText: "DateTime.now()",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "DateTime.fromUnixTimestamp",
					kind: monaco.languages.CompletionItemKind.Constructor,
					detail: "Constructor",
					documentation: {value: "Creates a new DateTime object from the given [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time), the number of **seconds** since January 1, 1970."},

					insertText: "DateTime.fromUnixTimestamp(${1:seconds})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "DateTime.fromUnixTimestampMillis",
					kind: monaco.languages.CompletionItemKind.Constructor,
					detail: "Constructor",
					documentation: {value: "Creates a new DateTime object from the given [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time), the number of **milliseconds** since January 1, 1970."},

					insertText: "DateTime.fromUnixTimestampMillis(${1:milliseconds})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "DateTime.fromUniversalTime",
					kind: monaco.languages.CompletionItemKind.Constructor,
					detail: "Constructor",
					documentation: {value: "Creates a new DateTime using the given units from a UTC time. The values accepted are similar to those found in the time value table returned by `DateTime.ToUniversalTime`."},

					insertText: "DateTime.fromUniversalTime(${1:year}, ${2:month}, ${3:day}, ${4:hour}, ${5:minute}, ${6:second}, ${7:millisecond})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "DateTime.fromLocalTime",
					kind: monaco.languages.CompletionItemKind.Constructor,
					detail: "Constructor",
					documentation: {value: "Creates a new DateTime using the given units from a local time. The values accepted are similar to those found in the time value table returned by `DateTime.ToLocalTime`."},

					insertText: "DateTime.fromLocalTime(${1:year}, ${2:month}, ${3:day}, ${4:hour}, ${5:minute}, ${6:second}, ${7:millisecond})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "DateTime.fromIsoDate",
					kind: monaco.languages.CompletionItemKind.Constructor,
					detail: "Constructor",
					documentation: {value: "Creates a DateTime from an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time string in UTC time, such as those returned by `DateTime.ToIsoDate`. If the string parsing fails, the function returns `nil`.\n\nAn example ISO 8601 date-time string would be `2020-01-02T10:30:45Z`, which represents January nd 2020 at 10:30 AM, 45 seconds."},

					insertText: "DateTime.fromIsoDate($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},

				
				// Random

				{
					label: "Random.new",
					kind: monaco.languages.CompletionItemKind.Constructor,
					detail: "Constructor",
					documentation: {value: "Creates a new Random object. If the seed parameter is not specified, it will use a seed pulled from an internal entropy source."},

					insertText: "Random.new(\"${1:seed}\")",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
			]}}});
			/* coroutine */ monaco.languages.registerCompletionItemProvider('lua', {provideCompletionItems: function () {return {suggestions: [
				{
					label: "coroutine",
					kind: monaco.languages.CompletionItemKind.Module,
					detail: "Library",
					documentation: {value: "A coroutine is used to perform multiple tasks at the same time from within the same script. A task doesn't need to have a defined ending point, but it does need to define particular times at which it will yield (pause) to let other things be worked on."},
				},
				{
					label: "coroutine.create",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Creates a new coroutine, with a function."},

					insertText: "coroutine.create($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "coroutine.resume",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Starts or continues the execution of the coroutine. The first time you resume a coroutine, it starts running its body. Additional arguments are passed as the arguments to the body function."},

					insertText: "coroutine.resume(${1:coroutine}, $0})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "coroutine.running",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the running coroutine."},

					insertText: "coroutine.running()",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "coroutine.status",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the status of the coroutine, as a string: ‘running', if the coroutine is running (that is, it called status); ‘suspended', if the coroutine is suspended in a call to yield, or if it has not started running yet; ‘normal' if the coroutine is active but not running (that is, it has resumed another coroutine); and ‘dead' if the coroutine has finished its body function, or if it has stopped with an error."},

					insertText: "coroutine.status($0})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "coroutine.wrap",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Creates a new coroutine, with a function. Returns a function that resumes the coroutine each time it is called. Any arguments passed to the function behave as the extra arguments to resume."},

					insertText: "coroutine.wrap($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "coroutine.yield",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Suspends the execution of the calling coroutine. Any arguments to yield are passed as extra results to resume."},

					insertText: "coroutine.yield($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
			]}}});
			
			/* math */ monaco.languages.registerCompletionItemProvider('lua', {provideCompletionItems: function () {return {suggestions: [
				{
					label: "math",
					kind: monaco.languages.CompletionItemKind.Module,
					detail: "Library",
					documentation: {value: "This library is an interface to the standard C math library, providing all of its functions inside the math table. When the documentation references `x` and arguments are not prefilled, assume it is the first or all argument(s)."},
				},
				{
					label: "math.abs",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the absolute value of x."},

					insertText: "math.abs($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.acos",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the arc cosine of x."},

					insertText: "math.acos($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.asin",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the arc sine of x."},

					insertText: "math.asin($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.atan",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the arc tangent of x (in radians)."},

					insertText: "math.atan($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.atan2",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the arc tangent of y/x (in radians), but uses the signs of both parameters to find the quadrant of the result. It also handles correctly the case of x being zero."},

					insertText: "math.(${1:x}, ${2:y})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.cell",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the smallest integer larger than or equal to x."},

					insertText: "math.cell($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.clamp",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns a number between min and max, inclusive."},

					insertText: "math.clamp(${1:x}, ${2:min}, ${3:max})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.cos",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the cosine of x (assumed to be in radians)."},

					insertText: "math.cos($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.cosh",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the hyperbolic cosine of x."},

					insertText: "math.cosh($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.deg",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the angle x (given in radians) in degrees."},

					insertText: "math.deg($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.exp",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the value e^x."},

					insertText: "math.exp($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.floor",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the largest integer smaller than or equal to x."},

					insertText: "math.floor($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.fmod",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the remainder of the division of x by y that rounds the quotient towards zero."},

					insertText: "math.fmod(${1:x}, ${2:y})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.frexp",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns m and e such that x = m*2^e, e is an integer and the absolute value of m is in the range [0.5, 1) (or zero when x is zero)."},

					insertText: "math.frexp($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.ldexp",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns m*2^e (e should be an integer)."},

					insertText: "math.ldexp(${1:x}, ${2:e})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.log",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the logarithm of x using the given base, or the mathematical constant e if no base is provided (natural logarithm)."},

					insertText: "math.(${1:x}, ${2:base})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.log10",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the base-10 logarithm of x."},

					insertText: "math.log10($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.max",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the maximum value among the numbers passed to the function."},

					insertText: "math.max($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.min",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the minimum value among the numbers passed to the function."},

					insertText: "math.min($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.modf",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns two numbers, the integral part of x and the fractional part of x."},

					insertText: "math.modf($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.noise",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns a perlin noise value. The returned value is most often between the range [-1, 1]. The returned value is sometimes will be outside of the range [-1,1], so if the interval is critical to you, you should use math.clamp(noise, -1, 1) on the output. Unspecified arguments are interpreted as 0."},

					insertText: "math.noise(${1:x}, ${2:y}, ${3:z})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.pow",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns x^y. You can also use the expression x^y to compute this value."},

					insertText: "math.pow(${1:x}, ${2:y})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.rad",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the angle x (given in degrees) in radians."},

					insertText: "math.rad($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.random",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "This function is an interface to the simple pseudo-random generator function rand provided by ANSI C. It returns a uniform pseudo-random integer in the range [min, max]"},

					insertText: "math.random(${1:min}, ${2:max})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.randomseed",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Sets x as the seed for the pseudo-random generator: equal seeds produce equal sequences of numbers."},

					insertText: "math.randomseed($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.round",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the integer with the smallest difference between it and the given number. For example, the value 5.8 returns 6.For values like 0.5 that are equidistant to two integers, the value with the greater difference between it and zero is chosen."},

					insertText: "math.round($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.sign",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns -1 if x < 0, 0 if x == 0, or 1 if x > 0."},

					insertText: "math.sign($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.sin",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the sine of x (assumed to be in radians)."},

					insertText: "math.sin($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.sinh",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the hyperbolic sine of x."},

					insertText: "math.sinh($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.sqrt",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the square root of x. You can also use the expression x^0.5 to compute this value."},

					insertText: "math.sqrt($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.tan",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the tangent of x (assumed to be in radians)."},

					insertText: "math.tan($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.tanh",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the hyperbolic tangent of x."},

					insertText: "math.tanh($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.huge",
					kind: monaco.languages.CompletionItemKind.Constant,
					detail: "Constant",
					documentation: {value: "The value HUGE_VAL, a value larger than or equal to any other numerical value."},

					insertText: "math.huge",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.pi",
					kind: monaco.languages.CompletionItemKind.Constant,
					detail: "Constant",
					documentation: {value: "The approximate value of π."},

					insertText: "math.pi",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
			]}}});
			/* os */ monaco.languages.registerCompletionItemProvider('lua', {provideCompletionItems: function () {return {suggestions: [
				{
					label: "os",
					kind: monaco.languages.CompletionItemKind.Module,
					detail: "Library",
					documentation: {value: "This library currently serves the purpose of providing information about the system time under the UTC format."},
				},
				{
					label: "os.time",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns how many seconds have passed since the Unix epoch (1 January 1970, 00:00:00), under current UTC time."},

					insertText: "os.time($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "os.difftime",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the number of seconds from time2 to time1."},

					insertText: "os.difftime(${1:time1}, ${2:time2})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "os.date",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Formats the given formatString with date/time information based on the given time, or if not provided, the value returned by os.time. Specifiers are inherited from C's \"strftime\""},

					insertText: "os.date(${1:formatString}, ${2:time})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "os.clock",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the amount of CPU time used by Lua in seconds. This value has high precision, about 1 microsecond."},

					insertText: "os.clock()",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
			]}}});
			/* string */ monaco.languages.registerCompletionItemProvider('lua', {provideCompletionItems: function () {return {suggestions: [
				{
					label: "string",
					kind: monaco.languages.CompletionItemKind.Module,
					detail: "Library",
					documentation: {value: "This library provides generic functions for string manipulation such as finding and extracting substrings, pattern matching, and more. It provides all of its functions inside the global `string` variable."},
				},
				{
					label: "string.byte",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the internal numerical codes of the characters text[start], text[start + 1], …, text[finish]."},

					insertText: "string.byte(${1:text}, ${2:start}, ${3:finish})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "string.char",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Receives zero or more integers. Returns a string with length equal to the number of arguments, in which each character has the internal numerical code equal to its corresponding argument."},

					insertText: "string.char($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "string.find",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Looks for the first match of pattern in the string `text`. If it finds a match, then find returns the indices of s where this occurrence starts and ends; otherwise, it returns nil. `init` specifies where to start the search (defaults to 1), and `plain` turns off the pattern matching facilities if `true`."},

					insertText: "string.find(${1:text}, ${2:pattern}, ${3:init}, ${4:plain})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "string.format",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string)."},

					insertText: "string.format($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "string.gmatch",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns an iterator function that, each time it is called, returns the next captures from pattern over the string `text`."},

					insertText: "string.gmatch(${1:text}, ${2:pattern})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "string.gsub",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Short for global substitution. Returns a copy of string in which all (or the first n, if given) occurrences of the pattern are substituted (replaced) with the given replacement. The second value returned is the total number of substitutions made. An optional final argument can be provided which specifies the maximum number of substitutions to make."},

					insertText: "string.gsub(${1:text}, ${2:pattern}, ${3:replacement}, ${4:replacements})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "string.len",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Receives a string and returns its length."},

					insertText: "string.len($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "string.lower",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Receives a string and returns a copy of this string with all uppercase letters changed to lowercase."},

					insertText: "string.lower($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "string.match",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Looks for the first match of pattern in the string `text`. If a match is found, it is returned; otherwise, it returns nil. A third, optional numerical argument init specifies where to start the search; its default value is 1 and can be negative."},

					insertText: "string.match(${1:text}, ${2:pattern}, ${3:init})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "string.rep",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns a string that is the concatenation of `copies` copies of the string `text`."},

					insertText: "string.rep(${1:text}, ${2:copies})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "string.reverse",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns a string that is the string reversed"},

					insertText: "string.reverse($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "string.split",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Splits a string into parts based on the defined separator character(s), returning a table of ordered results. If an empty “slice” is located, that part will be returned as an empty string. By default, the separator character is `,`."},

					insertText: "string.split(${1:text}, ${2:separator})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "string.sub",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the substring of `text` that starts at `start` and continues until `end`; `start and `end` can be negative. If `end` is absent, then it is assumed to be equal to -1 (which is the same as the string length).\n\nExample: `string.sub(\"Hello\", 2, 4)` --> ell"},

					insertText: "string.sub(${1:text}, ${2:start}, ${3:finish})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "string.upper",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Receives a string and returns a copy of this string with all lowercase letters changed to uppercase. All other characters are left unchanged."},

					insertText: "string.upper($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
			]}}});
			/* table */ monaco.languages.registerCompletionItemProvider('lua', {provideCompletionItems: function () {return {suggestions: [
				{
					label: "table",
					kind: monaco.languages.CompletionItemKind.Module,
					detail: "Library",
					documentation: {value: "This library provides generic functions for table/array manipulation, providing all its functions inside the global `table` variable."},
				},
				{
					label: "table.concat",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Given an array where all elements are strings or numbers, returns the string array[start] … separator … array[start + 1] … separator … array[finish]. The default value for separator is an empty string, the default for `start` is 1, and the default for `end` is `#array`. If `start` is greater than `end`, returns the empty string."},

					insertText: "table.concat(${1:array}, ${2:separator}, ${3:start}, ${4:finish})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "table.foreach",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Iterates over the provided table, passing the key and value of each iteration over to the provided function."},

					insertText: "table.foeach(${1:dictionary}, $0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "table.foreachi",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "This is similar to `table.foreach()` except that index-value pairs are passed, not key-value pairs."},

					insertText: "table.foreachi(${1:array}, $0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "table.getn",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the number of elements in the table passed."},

					insertText: "table.getn($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "table.insert",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Appends the provided value to the end of array `array`. The optional `position` value defaults to `#array + 1`, meaning that value is inserted at the end of array `array` unless otherwise specified."},

					insertText: "table.insert(${1:array}, ${2:position}, ${3:value})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "table.remove",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Removes from array `array` the element at position `position`, returning the value of the removed element. When `position` is an integer between 1 and #array, it shifts down the elements and erases element array[#array]."},

					insertText: "table.remove(${1:array}, ${2:position})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "table.sort",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Sorts elements of array `array` in a given order, from array[1] to array[#array]. If a function is given, then it must receive two elements and returns true when the first element must come before the second in the final order (so that not function(array[i + 1], array[i]) will be true after the sort). If a function is not given, then the standard Lua operator < is used instead."},

					insertText: "table.sort(${1:array}, ${0})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "table.pack",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns a new table with all arguments stored into keys 1, 2, etc. and with a field “n” with the total number of arguments. The resulting table may not be a sequence."},

					insertText: "table.pack($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "table.unpack",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the elements from the given list. By default, `start` is 1 and `finish` is `#list`."},

					insertText: "table.unpack(${1:list}, ${2:start}, ${3:finish})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "table.move",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Moves elements from table `from` to table `to`, performing the equivalent to the following multiple assignment: to[index], ... = from[start], ..., from[finish]. In easier terms, move index `start` through `finish` in `from` to index `index` in `to`."},

					insertText: "table.move(${1:from}, ${2:start}, ${3:finish}, ${4:index}, ${5:to})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "table.create",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Creates a table with the array portion allocated to the given number of elements, optionally filled with the given value."},

					insertText: "table.create(${1:count}, ${2:value})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "table.clear",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Sets the value for all keys within the given table to nil. This causes the # operator to return 0 for the given table. This function does not delete/destroy the table provided to it. This function is meant to be used specifically for tables that are to be re-used."},

					insertText: "table.clear($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "table.find",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Within the given array-like table `array`, find the first occurrence of value `value`, starting from index `init` or the beginning if not provided. If the value is not found, `nil` is returned."},

					insertText: "table.find(${1:array}, ${2:value}, ${3:init})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
			]}}});
			/* utf8 */ monaco.languages.registerCompletionItemProvider('lua', {provideCompletionItems: function () {return {suggestions: [
				{
					label: "utf8",
					kind: monaco.languages.CompletionItemKind.Module,
					detail: "Library",
					documentation: {value: "This library provides basic support for UTF-8 encoding. This library does not provide any support for Unicode other than the handling of the encoding."},
				},
				{
					label: "utf8.char",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Receives zero or more codepoints as integers, converts each one to its corresponding UTF-8 byte sequence and returns a string with the concatenation of all these sequences."},

					insertText: "utf8.char($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "utf8.codes",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns an iterator function that will iterate over all codepoints in the provided string."},

					insertText: "utf8.codes($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "utf8.codepoint",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the codepoints (as integers) from all codepoints in the provided string (`text`) that start between byte positions `start` and `finish` (both included)."},

					insertText: "utf8.codepoint(${1:text}, ${2:start}, ${3:finish})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "utf8.len",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the number of UTF-8 codepoints in the string `text` that start between positions `start` and `finish` (both inclusive)."},

					insertText: "utf8.len(${1:text}, ${2:start}, ${3:finish})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "utf8.offset",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns the position (in bytes) where the encoding of the `codepoint`-th codepoint of `text` (counting from byte position `start`) starts."},

					insertText: "utf8.offset(${1:text}, ${2:codepoint}, ${3:start})",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "utf8.graphemes",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Returns an iterator function that will iterate the grapheme clusters of the string."},

					insertText: "utf8.graphemes($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "utf8.nfcnormalize",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Converts the input string to Normal Form C, which tries to convert decomposed characters into composed characters."},

					insertText: "utf8.nfcnomralize($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "utf8.nfdnormalize",
					kind: monaco.languages.CompletionItemKind.Function,
					detail: "Function",
					documentation: {value: "Converts the input string to Normal Form D, which tries to break up composed characters into decomposed characters."},

					insertText: "utf8.nfdnormalize($0)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "utf8.charpattern",
					kind: monaco.languages.CompletionItemKind.Constant,
					detail: "Constant",
					documentation: 'The pattern "[%z\\x01-\\x7F\\xC2-\\xF4][\\x80-\\xBF]*", which matches exactly zero or more UTF-8 byte sequence, assuming that the subject is a valid UTF-8 string.',

					insertText: "utf8.charpattern",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
			]}}});
			/* Snippets */ monaco.languages.registerCompletionItemProvider('lua', {provideCompletionItems: function () {return {suggestions: [
				{
					label: "function(...)",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Function (Variadic)",
					documentation: {value: "A varaiadic function is a function that allows you to use infinite arguments inside of a function, like `print()`. After packing the `...` token, you can iterate through it with an array's `for` loop."},
					preselect: true,

					insertText: [
						"local function ${1:name}(${2:parameters}, ...)",
						"\tlocal arguments = table.pack(...)",
						"\t$0",
						"end",
					].join("\n"),
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "for i, v in ipairs()",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Loop",
					documentation: {value: "This is a commonly used variation of the `for` loop which iterates through an array with the `ipairs` iterator. `i` means index, and `v` means value."},
					filterText: "for i, v in ipairs",
					preselect: true,

					insertText: [
						"for i, v in ipairs(${1:array}) do",
						"\t$0",
						"end",
					].join("\n"),
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "for k, v in pairs()",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Loop",
					documentation: {value: "This is a commonly used variation of the `for` loop which iterates through a dictionary with the `pairs` iterator. `k` means key, and `v` means value. The loop may not return items in the same way they're declared."},
					filterText: "for k, v in pairs",
					preselect: true,

					insertText: [
						"for k, v in pairs(${1:dictionary}) do",
						"\t$0",
						"end",
					].join("\n"),
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "while true do",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Loop",
					documentation: {value: "Creates an infinite loop in a new thread since `true` is `true`. Includes a `wait()` and is wrapped in a coroutine to prevent the game from freezing up from overload."},
					filterText: "while true",
					preselect: true,

					insertText: [
						"coroutine.wrap(function()",
						"\twhile true do",
						"\t\t$0",
						"\t\twait(1)",
						"\tend",
						"end)()",
					].join("\n"),
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "while wait() do",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Loop",
					documentation: {value: "Shorthand for\n\n```lua\ncoroutine.wrap(function()\n\twhile true do\n\t\twait()\n\tend\nend)()\n```\n\nalthough not using this is much more syntactically correct."},
					filterText: "while wait",

					insertText: [
						"coroutine.wrap(function()",
						"\twhile true do",
						"\t\t$0",
						"\t\twait()",
						"\tend",
						"end)()",
					].join("\n"),
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "method",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Snippet",
					documentation: {value: "Method template for a class, which automatically defines the `self` variable which references the table."},

					insertText: [
						"function ${1:class}:${2:method}(${3:arguments})",
						"\t$0",
						"end",
					].join("\n"),
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "loadstring(http)",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Snippet",
					documentation: {value: "This snippet loads the Lua code from a website and executes it. (Grabs raw text)"},

					insertText: "loadstring(game:HttpGet(\"${1:url}\"))()",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "benchmark",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Snippet",
					documentation: {value: "Benchmark code to run for the performance of an operation."},

					insertText: [
						"local startTime = os.clock()",
						"$0",
						"local deltaTime = os.clock() - startTime",
					].join("\n"),
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "HUGE_VAL",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Snippet",
					documentation: {value: "The value which can only be used when returned from `math.huge`."},

					insertText: "math.huge()",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "INT32_MAX",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Snippet",
					documentation: {value: "Autofills 2³² - 1."},

					insertText: "2^32 - 1",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "INT32_MIN",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Snippet",
					documentation: {value: "Autofills -2³² - 1."},

					insertText: "-2^32 - 1",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "Infinity",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Snippet",
					documentation: {value: "Autofills 10 ^ 1000."},

					insertText: "10^1000",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "math.e",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Snippet",
					documentation: {value: "Uses `math.exp` and gets the power of e^1, which is just e."},

					insertText: "math.exp(1)",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "Class",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Snippet",
					documentation: {value: "A simple and accepted boilerplate template for custom objects. Not a real keyword or function."},

					insertText: [
						"local ${1:Class} = {}",
						"${1:Class}.__index = ${1:Class}",
						"",
						"function ${1:Class}.new()",
						"\tlocal ${2:Object} = setmetatable({}, ${1:Class})",
						"\t$0",
						"\treturn ${2:Object}",
						"end",
					].join("\n"),
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "iterator",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Snippet",
					documentation: {value: "Autofills a factory which returns an [iterator function](https://www.lua.org/pil/7.1.html), for use in a generic\n```lua\nfor ... in iterator() do\n\t\nend\n```"},

					insertText: [
						"local function ${1:factory}(Table)",
						"\tlocal State = 0",
						"\treturn function()",
						"\t\tState += 1",
						"\t\t$0",
						"\t\treturn Table[State]",
						"\tend",
						"end",
					].join("\n"),
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "pages",
					kind: monaco.languages.CompletionItemKind.Snippet,
					detail: "Snippet",
					documentation: {value: "Autofills a factory function `pages` which loops through a Pages instance with the returned iterator returning the `Item` and `PageNumber` in the current iteration.\n\n```lua\nfor v, i in pages(PagesInstance) do\n\t-- something\nend\n```"},

					insertText: [
						"local function pages(Pages)",
						"\treturn coroutine.wrap(function()",
						"\t\tlocal Iteration = 1",
						"\t\twhile true do",
						"\t\t\tfor _, Item in ipairs(Pages:GetCurrentPage()) do",
						"\t\t\t\tcoroutine.yield(Item, Iteration)",
						"\t\t\tend",
						"\t\t\tif Pages.IsFinished then",
						"\t\t\t\tbreak",
						"\t\t\tend",
						"\t\t\tPages:AdvanceToNextPageAsync()",
						"\t\t\tIteration += 1",
						"\t\tend",
						"\tend)",
						"end",
					].join("\n"),
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
			]}}});
			/* Metatables */ monaco.languages.registerCompletionItemProvider('lua', {provideCompletionItems: function () {return {suggestions: [
				{
					label: "__index",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "Fires when table[index] is indexed, if table[index] is nil. Can also be set to a table, in which case that table will be indexed."},

					insertText: "__index = function(${1:self}, ${2:index})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__newindex",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "Fires when table[index] tries to be set (table[index] = value), if table[index] is nil. Can also be set to a table, in which case that table will be indexed."},

					insertText: "__newindex = function(${1:self}, ${2:index}, ${3:value})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__call",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "Fires when the table is called like a function, ... is the arguments that were passed."},

					insertText: "__call  = function(${1:self}, ${2:...})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__concat",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "Fires when the .. concatenation operator is used on the table."},

					insertText: "__concat = function(${1:self}, ${2:value})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__unm",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "Fires when the unary – operator is used on the table."},

					insertText: "__unm = function(${1:self})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__add",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "The + addition operator."},

					insertText: "__add = function(${1:self}, ${2:value})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__sub",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "The - subtraction operator."},

					insertText: "__sub = function(${1:self}, ${2:value})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__mul",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "The * multiplication operator."},

					insertText: "__mul = function(${1:self}, ${2:value})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__div",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "The / division operator."},

					insertText: "__div = function(${1:self}, ${2:value})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__mod",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "The % modulus operator."},

					insertText: "__mod = function(${1:self}, ${2:value})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__pow",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "The ^ exponentiation operator."},

					insertText: "__pow = function(${1:self}, ${2:value})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__eq",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "The == equal to operator."},

					insertText: "__eq = function(${1:self}, ${2:value})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__lt",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "The < less than operator\n\nUsing the >= greater than or equal to operator will invoke this metamethod and return the opposite of what this returns, as greater than or equal to is the same as not less than."},

					insertText: "__lt = function(${1:self}, ${2:value})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__le",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "The <= operator\n\nUsing the > greater than operator will invoke this metamethod and return the opposite of what this returns, as greater than is the same as not less than or equal to."},

					insertText: "__le = function(${1:self}, ${2:value})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__len",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "Fired when the # length operator is used on the Object.\n\nOnly userdatas actually respect the __len() metamethod in Lua 5.1."},

					insertText: "__len = function(${1:self})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__tostring",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "Fired when tostring is called on the table."},

					insertText: "__tostring = function(${1:self})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__metatable",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "If present, locks the metatable so `getmetatable` will return this instead of the metatable and `setmetatable` will error. Non-function value."},

					insertText: "__metatable = \"${1:The metatable is locked}\"",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__mode",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "Used in weak tables, declaring whether the keys and/or values of a table are weak."},

					insertText: "__mode",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
				{
					label: "__gc",
					kind: monaco.languages.CompletionItemKind.Method,
					detail: "Metamethod",
					documentation: {value: "Fired when the table is garbage-collected."},
					tags: [monaco.languages.CompletionItemTag.Deprecated],

					insertText: "__gc = function(${1:self})\n\t$0\nend",
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				},
			]
			}
			}
			});

			monaco.editor.defineTheme('vsLight', {base: 'vs'});
			monaco.editor.defineTheme('vsDark', {base: 'vs-dark'});
			
            monaco.editor.defineTheme('azlyph', { // also synapse's theme
				base: 'vs-dark',
				inherit: true,
				rules: [
                    { token: 'keyword', foreground: '777FE8', fontStyle: "bold"},
					{token: 'global', foreground: '84d6f7', fontStyle: "bold"},
					{token: 'type', foreground: '656565'},
                    { token: 'string', foreground: '656565'},
                    { token: 'number', foreground: '979797'},
					{token: 'operator', foreground: 'ffffff'},
					{token: 'comment', foreground: '454545'},
					{token: 'comment.todo', fontStyle: "bold"},
				],
				colors: {
                    'editor.background': '#040404',
					'editor.foreground': '#cccccc',
				}
			});

			editor = monaco.editor.create(document.getElementById('container'), {
				value: "--Welcome to Azlyph",
				language: 'lua',
				theme: "azlyph",
				folding: true,
				scrollbar: {
					useShadows: false,
					verticalHasArrows: true,
				},
				dragAndDrop: true,
				links: true,
				minimap: {enabled: false,},
				showFoldingControls: "always",
				smoothScrolling: true,
				colorDecorators: true,
				lineNumbers: "on",
				lineNumbersMinChars: 3,
				roundedSelection: true,
				scrollBeyondLastLine: false,
				acceptSuggestionOnEnter: "on",
				autoClosingBrackets: "always",
				detectIndentation: true,
				autoIndent: "full",
				insertSpaces: false,
				cursorBlinking: "phase",
				formatOnPaste: true,
				formatOnType: true,
				snippetSuggestions: "bottom",
				stickyTabStops: true,
				wordBasedSuggestionsOnlySameLanguage: false,
			});

			function addAction(id, label, run, keybinds) {
				editor.addAction({
					id: id,
					label: label,
					precondition: null,
					keybindings: keybinds,
					keybindingContext: null,
					contextMenuGroupId: 'navigation',
					contextMenuOrder: 1.5,
					run: function() {
						run()
						return null;
					}
				});
			}

			addAction('monaco-help', "~ Help", function() {
				document.location.href = "https://github.com/EthanMcBloxxer/Rosploco/";
			}, [monaco.KeyMod.chord(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_H)]);
			addAction('save', "Save", function() {
				saveTextAs(editor.getValue(), "script.lua");
			}, [monaco.KeyMod.chord(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_S)]);
			addAction('clear-editor', "Clear", function() {
				editor.setValue("");
			});
			addAction('refresh', "Refresh", function() {
				var replaceValue = editor.getValue()
				editor.setValue(replaceValue);
				replaceValue = null
			}, [monaco.KeyMod.chord(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_R)]);

			window.onresize = function () {editor.layout();}
		});
		var getText = function () {return editor.getValue();}
		var setText = function (x) {editor.setValue(x);}
		var setTheme = function (themeName) {monaco.editor.setTheme(themeName)}

		var setImage = function (x) {
			document.getElementsByClassName("lines-content monaco-editor-background")[0].style.backgroundImage = "url=(" + x + ")";
			document.getElementsByClassName("margin")[0].style.backgroundImage = "url=(" + x + ")";
		}

		var switchMinimapOn = function (flag) { editor.updateOptions({ minimap: { enabled: true, } }); }
		var switchMinimapOff = function (flag) { editor.updateOptions({ minimap: { enabled: false, } }); }

		var switchReadonly = function (flag) {editor.updateOptions({readOnly: flag,});}
		var switchRenderWhitespace = function (op) {editor.updateOptions({renderWhitespace: op,});}
		var switchLinks = function (flag) {editor.updateOptions({links: flag,});}
		var switchLineHeight = function (num) {editor.updateOptions({lineHeight: num,});}
		var switchFontSize = function (num) {editor.updateOptions({fontSize: num,});}
		var switchFolding = function (flag) {editor.updateOptions({folding: flag,});}
		var switchAutoIndent = function (flag) {editor.updateOptions({autoIndent: flag,});}
		var switchFontFamily = function (name) {editor.updateOptions({fontFamily: name,});}
		var switchFontLigatures = function (flag) {editor.updateOptions({fontLigatures: flag,});}

		var addIntellisense = function (l, k, d, i) {
			var t;
			switch (k) {
				case "Class": t = monaco.languages.CompletionItemKind.Class; break;
				case "Color": t = monaco.languages.CompletionItemKind.Color; break;
				case "Constructor": t = monaco.languages.CompletionItemKind.Constructor; break;
				case "Enum": t = monaco.languages.CompletionItemKind.Enum; break;
				case "Field": t = monaco.languages.CompletionItemKind.Field; break;
				case "File": t = monaco.languages.CompletionItemKind.File; break;
				case "Folder": t = monaco.languages.CompletionItemKind.Folder; break;
				case "Function": t = monaco.languages.CompletionItemKind.Method; break;
				case "Interface": t = monaco.languages.CompletionItemKind.Interface; break;
				case "Keyword": t = monaco.languages.CompletionItemKind.Keyword; break;
				case "Method": t = monaco.languages.CompletionItemKind.Method; break;
				case "Module": t = monaco.languages.CompletionItemKind.Module; break;
				case "Property": t = monaco.languages.CompletionItemKind.Property; break;
				case "Reference": t = monaco.languages.CompletionItemKind.Reference; break;
				case "Snippet": t = monaco.languages.CompletionItemKind.Snippet; break;
				case "Text": t = monaco.languages.CompletionItemKind.Text; break;
				case "Unit": t = monaco.languages.CompletionItemKind.Unit; break;
				case "Value": t = monaco.languages.CompletionItemKind.Value; break;
				case "Variable": t = monaco.languages.CompletionItemKind.Variable; break;
			}

			monaco.languages.registerCompletionItemProvider('lua', {provideCompletionItems: function () {return {suggestions: [
				{
					label: l,
					kind: t,
					documentation: {value: d},

					insertText: i,
					insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
				}
			]}}});
		}

		var showErr = function (line, column, endline, endcolumn, errMessage) {
			editor.revealPositionInCenter({ lineNumber: line, column: column });
			editor.deltaDecorations([], [
				{
					range: new monaco.Range(line, column, endline, endcolumn),
					options: {
						inlineClassName: 'squiggly-error',
						hoverMessage: {value: errMessage,},
					},
				},
			]);
		}

		var setScroll = function (line) {editor.revealLineInCenter({ lineNumber: line });}

		var refresh = function () {
			var text = getText();
			setText("");
			editor.trigger('keyboard', 'type', { text: text });
		}
	</script>
</body>

</html>

<!--[LICENSE]>

The MIT License (MIT)

Copyright (c) 2016 - present Microsoft Corporation

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

-----

The MIT License (MIT)

Copyright (c) 2021 - present EthanMcBloxxer

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

<![END]-->
